# AE2 自動クラフト実行例

## 実例: ダイヤモンドの剣の自動クラフト

このドキュメントでは、「ダイヤモンドの剣」を1本クラフトする場合の具体的なフローを、実際のクラス処理と共に説明します。

## 前提条件
- MEネットワークにダイヤモンド（x2）と棒（x1）が保存済み
- クラフトCPUが1台利用可能
- ダイヤモンドの剣のクラフトパターンが登録済み

## ステップバイステップ実行例

### Step 1: 要求受信
```java
// プレイヤーがクラフトターミナルでダイヤモンドの剣をリクエスト
ICraftingRequester requester = craftingTerminal;
GenericStack request = new GenericStack(Items.DIAMOND_SWORD, 1);

// CraftingService.requestCrafting() が呼び出される
CraftingService service = grid.getCraftingService();
ICraftingSubmitResult result = service.requestCrafting(
    requester, 
    request, 
    null,  // 自動CPU選択
    CalculationStrategy.CRAFT_LESS
);
```

**内部処理:**
- `CraftingService` がリクエストを受信
- 利用可能なCPUをスキャン
- 計算戦略を `CRAFT_LESS` に設定（必要最小限のみクラフト）

### Step 2: 計算開始
```java
// CraftingCalculation インスタンスの作成
CraftingCalculation calc = new CraftingCalculation(
    level,           // Minecraft世界
    grid,            // MEネットワーク
    requester,       // 要求者
    request,         // ダイヤモンドの剣 x1
    strategy         // CRAFT_LESS戦略
);

// ネットワーク状態のスナップショット作成
NetworkCraftingSimulationState networkInv = 
    new NetworkCraftingSimulationState(storage, actionSource);
```

**状態確認:**
- ダイヤモンド: 利用可能数 = 2個
- 棒: 利用可能数 = 1個
- ダイヤモンドの剣: 利用可能数 = 0個（クラフト必要）

### Step 3: クラフトツリー構築
```java
// ルートノード作成（ダイヤモンドの剣）
CraftingTreeNode rootNode = new CraftingTreeNode(
    craftingService,
    calc,
    Items.DIAMOND_SWORD,  // 目標アイテム
    1,                    // 必要数量
    null,                 // 親ノード（なし）
    -1                    // 深度（ルート）
);

// パターン検索
List<IPatternDetails> patterns = craftingService.getCraftingFor(
    Items.DIAMOND_SWORD,
    null,  // 全ての次元で検索
    actionSource
);

// ダイヤモンドの剣のクラフトパターンが見つかった場合
AECraftingPattern swordPattern = patterns.get(0);
```

**パターン解析結果:**
```
入力要件:
- ダイヤモンド x2 → 利用可能 ✓
- 棒 x1 → 利用可能 ✓

出力:
- ダイヤモンドの剣 x1
```

### Step 4: プラン完成
```java
// CraftingPlan の生成
CraftingPlan plan = calc.createPlan();

// プラン内容:
plan.finalOutput();     // ダイヤモンドの剣 x1
plan.patternTimes();    // {swordPattern: 1回}
plan.emittedItems();    // {ダイヤモンドの剣: 1個}
plan.missingItems();    // {} (空 - 全材料利用可能)
plan.bytes();           // 必要ストレージバイト数
```

**計算結果:**
- 実行必要パターン: ダイヤモンドの剣パターン x 1回
- 必要材料: 全て利用可能
- 推定実行時間: 約200tick (10秒)

### Step 5: CPU割当
```java
// 適切なCPU検索
Collection<ICraftingCPU> cpus = craftingService.getCpus();
ICraftingCPU selectedCpu = null;

for (ICraftingCPU cpu : cpus) {
    if (cpu.isIdleOrReturning() && 
        cpu.getAvailableStorage() >= plan.bytes()) {
        selectedCpu = cpu;
        break;
    }
}

// CraftingCPUCluster が選択される
CraftingCPUCluster cluster = (CraftingCPUCluster) selectedCpu;
```

### Step 6: ジョブ作成と実行開始
```java
// ExecutingCraftingJob の作成
UUID craftId = UUID.randomUUID();
CraftingLink link = new CraftingLink(requester, selectedCpu, craftId, false);

ExecutingCraftingJob job = new ExecutingCraftingJob(
    plan,
    cluster::postCraftingDifference,  // 完成通知リスナー
    link,
    playerId
);

// 初期状態設定
job.finalOutput = new GenericStack(Items.DIAMOND_SWORD, 1);
job.remainingAmount = 1;
job.waitingFor.insert(Items.DIAMOND_SWORD, 1, Actionable.MODULATE);
job.tasks.put(swordPattern, new TaskProgress().value = 1);
```

### Step 7: CPU実行ループ
```java
// CraftingCPUCluster.tick() による継続実行
@Override
public void tick() {
    if (craftingLogic.hasJob()) {
        ExecutingCraftingJob job = craftingLogic.getCurrentJob();
        
        // Step 7.1: 材料準備確認
        if (canExecutePattern(swordPattern)) {
            // ダイヤモンド x2 をネットワークから取得
            storage.extract(Items.DIAMOND, 2, Actionable.MODULATE, actionSource);
            // 棒 x1 をネットワークから取得  
            storage.extract(Items.STICK, 1, Actionable.MODULATE, actionSource);
            
            // Step 7.2: パターンプロバイダーに送信
            IPatternDetails pattern = swordPattern;
            ICraftingProvider provider = findProvider(pattern);
            provider.pushPattern(pattern, craftingInv);
            
            // Step 7.3: タスク進捗更新
            TaskProgress progress = job.tasks.get(swordPattern);
            progress.value--;  // 1 → 0 (完了)
        }
    }
}
```

### Step 8: 完成処理
```java
// パターンプロバイダーからの完成通知
public void onPatternComplete(IPatternDetails pattern, AEKey output) {
    // ダイヤモンドの剣が完成
    
    // Step 8.1: 完成アイテムを待機リストから削除
    job.waitingFor.extract(Items.DIAMOND_SWORD, 1, Actionable.MODULATE);
    
    // Step 8.2: 残り数量を減算
    job.remainingAmount--;  // 1 → 0
    
    // Step 8.3: 完了判定
    if (job.isComplete()) {
        // Step 8.4: 最終出力をリクエスターに配送
        requester.jobStateChange(link);
        
        // Step 8.5: リンク完了マーク
        link.markDone();
        
        // Step 8.6: CPU解放
        cluster.craftingLogic.cancel();
        
        // Step 8.7: ネットワークイベント発行
        grid.postEvent(new GridCraftingCpuChange(cluster.getActionableNode()));
    }
}
```

## 実行時間ライン

```
時刻    イベント                              状態
T+0     要求受信                              計算開始
T+50    計算完了                              CPU割当
T+60    ジョブ開始                            材料取得
T+80    パターン送信                          実行中
T+200   クラフト完了                          完成アイテム生成
T+210   配送完了                              ジョブ完了
```

## エラーケース例

### ケース1: 材料不足
```java
// ダイヤモンドが1個しかない場合
if (availableDiamonds < requiredDiamonds) {
    calc.addMissing(Items.DIAMOND, requiredDiamonds - availableDiamonds);
    // 結果: plan.missingItems() に {ダイヤモンド: 1個} が記録
    // プランは実行不可として返される
}
```

### ケース2: CPU容量不足
```java
// 選択されたCPUのストレージが不足の場合
if (cpu.getAvailableStorage() < plan.bytes()) {
    // 他のCPUを検索、または失敗を返す
    return CraftingSubmitResult.INCOMPLETE_PLAN;
}
```

### ケース3: パターンプロバイダー応答なし
```java
// パターン送信後、一定時間応答がない場合
if (timeTracker.getElapsedTimeForPattern(pattern) > TIMEOUT) {
    // パターンを再送信、または別のプロバイダーを試行
    retryPattern(pattern);
}
```

## まとめ

この例では、シンプルなダイヤモンドの剣のクラフトでも、多数のクラスとステップが連携して動作することがわかります。AE2のアーキテクチャは、この基本的なフローを拡張して、非常に複雑なマルチステップクラフトや並列処理にも対応できるように設計されています。