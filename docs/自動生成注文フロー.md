# Applied Energistics 2 自動生成の注文フロー説明書

このドキュメントでは、Applied Energistics 2（AE2）における自動生成の注文を受けてから完了するまでの詳細なフローを、実際のJavaクラスを用いて説明します。

## 概要

AE2の自動クラフトシステムは、MEネットワーク内でアイテムの自動製作を管理する複雑なシステムです。このシステムは以下の主要なフェーズに分かれています：

1. **注文受信**: クラフト要求の受信と計算
2. **計画立案**: クラフトプランの作成
3. **CPU割当**: 適切なクラフトCPUへの割当
4. **実行管理**: 実際のクラフト実行の監視と制御
5. **完了処理**: クラフト完了後の後処理

## 主要クラス構成

### サービス層
- `appeng.me.service.CraftingService`: MEネットワーク全体のクラフト管理
- `appeng.me.service.StorageService`: ストレージ管理サービス
- `appeng.me.service.EnergyService`: エネルギー管理サービス

### クラフト計算層
- `appeng.crafting.CraftingCalculation`: クラフト計算のメインクラス
- `appeng.crafting.CraftingTreeNode`: クラフトツリーのノード管理
- `appeng.crafting.CraftingPlan`: 計算結果としてのクラフトプラン

### 実行層
- `appeng.crafting.execution.ExecutingCraftingJob`: 実行中のクラフトジョブ管理
- `appeng.me.cluster.implementations.CraftingCPUCluster`: クラフトCPUクラスターの実装
- `appeng.crafting.execution.CraftingCpuLogic`: CPUの論理制御

### リンク管理層
- `appeng.crafting.CraftingLink`: クラフト要求者とCPU間のリンク
- `appeng.crafting.CraftingLinkNexus`: 複数リンクの管理

### パターン管理層
- `appeng.crafting.pattern.AECraftingPattern`: 標準クラフトパターン
- `appeng.crafting.pattern.AEProcessingPattern`: 加工パターン

## 詳細フロー説明

### フェーズ1: 注文受信と初期処理

#### 1.1 要求受信 (`CraftingService.requestCrafting()`)
```java
// appeng.me.service.CraftingService
public ICraftingSubmitResult requestCrafting(ICraftingRequester requester, 
    GenericStack what, ICraftingCPU cpu, CalculationStrategy strategy)
```

**処理内容:**
- クラフト要求者 (`ICraftingRequester`) からの要求を受信
- 要求されたアイテム (`GenericStack`) の詳細を解析
- 指定されたクラフトCPU (`ICraftingCPU`) の可用性を確認
- 計算戦略 (`CalculationStrategy`) を適用

#### 1.2 計算準備 (`CraftingCalculation` のインスタンス化)
```java
// appeng.crafting.CraftingCalculation
public CraftingCalculation(Level level, IGrid grid, 
    ICraftingSimulationRequester simRequester, GenericStack output, 
    CalculationStrategy strategy)
```

**処理内容:**
- MEネットワークの現在の状態をスナップショット (`NetworkCraftingSimulationState`)
- クラフトツリーのルートノード (`CraftingTreeNode`) を作成
- 不足アイテムの追跡用カウンター (`KeyCounter missing`) を初期化

### フェーズ2: クラフトプラン立案

#### 2.1 ツリー構築 (`CraftingTreeNode` による再帰的処理)
```java
// appeng.crafting.CraftingTreeNode
private void buildCraftingTree()
```

**処理内容:**
- 要求されたアイテムのクラフトレシピ/パターンを検索
- 必要な中間材料を特定し、再帰的にサブノードを作成
- 各ノードで必要な数量を計算
- 利用可能なクラフトプロバイダー (`ICraftingProvider`) を調査

#### 2.2 パターンマッチング
```java
// パターンの種類別処理
- AECraftingPattern: 標準クラフトテーブルレシピ
- AEProcessingPattern: 機械加工パターン
- AESmithingTablePattern: 鍛冶台パターン
- AEStonecuttingPattern: 石切台パターン
```

#### 2.3 プラン完成 (`CraftingPlan` 生成)
```java
// appeng.crafting.CraftingPlan
public CraftingPlan createPlan()
```

**処理内容:**
- 最終的な出力アイテムとその数量を確定
- パターン別の実行回数を計算 (`patternTimes`)
- 必要な中間アイテムのリストを生成 (`emittedItems`)
- 不足アイテムがある場合は `missingItems` に記録

### フェーズ3: CPU割当と実行準備

#### 3.1 CPU選択 (`CraftingService.findSuitableCpu()`)
```java
// 適切なCPUの選択基準:
- ストレージ容量の十分性
- 現在の使用状況（アイドル状態）
- CPUの種類と設定 (CpuSelectionMode)
```

#### 3.2 ジョブ作成 (`ExecutingCraftingJob` インスタンス化)
```java
// appeng.crafting.execution.ExecutingCraftingJob
ExecutingCraftingJob(ICraftingPlan plan, 
    CraftingDifferenceListener postCraftingDifference, 
    CraftingLink link, @Nullable Integer playerId)
```

**処理内容:**
- プランから最終出力と残り数量を設定 (`finalOutput`, `remainingAmount`)
- 待機アイテムのインベントリを初期化 (`ListCraftingInventory waitingFor`)
- パターン別のタスク進捗を初期化 (`Map<IPatternDetails, TaskProgress> tasks`)
- 経過時間追跡を開始 (`ElapsedTimeTracker timeTracker`)

#### 3.3 リンク確立 (`CraftingLink` 作成)
```java
// appeng.crafting.CraftingLink
public CraftingLink(ICraftingRequester req, ICraftingCPU cpu, 
    UUID craftId, boolean standalone)
```

**処理内容:**
- 要求者とCPU間の通信リンクを確立
- 一意のクラフトID (`UUID craftId`) を生成
- キャンセル/完了状態の管理フラグを初期化

### フェーズ4: 実行管理

#### 4.1 CPU論理制御開始 (`CraftingCpuLogic.submitJob()`)
```java
// appeng.crafting.execution.CraftingCpuLogic
public ICraftingSubmitResult submitJob(IGrid grid, ICraftingPlan plan, 
    ICraftingRequester requester, @Nullable ICraftingCPU target)
```

#### 4.2 パターン実行ループ
```java
// CraftingCPUCluster.tick() によるメインループ
while (!job.isComplete()) {
    // 1. 利用可能な材料をチェック
    // 2. 実行可能なパターンを特定
    // 3. パターンを対応するプロバイダーに送信
    // 4. 結果を待機アイテムに反映
    // 5. 進捗状況を更新
}
```

#### 4.3 材料管理とフロー制御
```java
// appeng.crafting.inv.ListCraftingInventory
// 待機中のアイテムの管理:
- insert(): 完成したアイテムの受入
- extract(): 次のパターンに必要なアイテムの取出
- onCraftingDifference(): アイテム変更の通知
```

#### 4.4 進捗追跡
```java
// appeng.crafting.execution.ElapsedTimeTracker
// 各アイテムタイプの処理時間を追跡:
- addMaxItems(): 最大アイテム数の設定
- addCompletedItems(): 完成アイテム数の追加
- getElapsedTimeForItem(): アイテム別経過時間
```

### フェーズ5: 完了処理

#### 5.1 完了判定
```java
// ExecutingCraftingJob.isComplete()
return remainingAmount <= 0 && 
       waitingFor.isEmpty() && 
       tasks.values().stream().allMatch(TaskProgress::isComplete);
```

#### 5.2 最終出力配送
```java
// CraftingCpuLogic.extractItems()
// 最終的な出力アイテムを要求者に配送
private void deliverFinalOutput(ICraftingRequester requester)
```

#### 5.3 リソース解放
```java
// CraftingLink.markDone()
// リンクを完了としてマークし、リソースを解放
public void markDone()
```

#### 5.4 イベント通知
```java
// GridCraftingCpuChange イベントの発行
// ネットワーク内の他のコンポーネントに完了を通知
grid.postEvent(new GridCraftingCpuChange(node));
```

## エラーハンドリングとフォールバック

### 材料不足時の処理
```java
// CraftingCalculation.addMissing()
// 不足材料を missing KeyCounter に記録
void addMissing(AEKey what, long amount)
```

### パターン実行失敗時の処理
```java
// TaskProgress での再試行管理
// パターンプロバイダーが応答しない場合の再送機構
```

### CPU障害時の処理
```java
// CraftingLink.cancel()
// 実行中のジョブをキャンセルし、材料を返却
public void cancel()
```

## まとめ

AE2の自動クラフトシステムは、複数の階層に分かれた sophisticated なアーキテクチャを持っています：

1. **サービス層**: MEネットワーク全体の管理
2. **計算層**: 効率的なクラフトプランの立案
3. **実行層**: リアルタイムでの材料フローと進捗管理
4. **通信層**: 要求者とCPU間の確実な連携

各クラスは明確な責任分担を持ち、拡張性と保守性を考慮した設計となっています。この設計により、大規模で複雑なクラフト要求も効率的に処理できる仕組みが実現されています。